Gestión de Usuarios:
Core INICIAL
Usuarios
Creación de entidad Usuario


Creación de Value Object Email


Creación de interfaz IUsuarioRepository


Implementación de UserManagerService


Implementación de lógica de hasheo de contraseñas


Roles y Claims
Creación de entidad Rol


Creación de relación Usuario-Rol


Creación de interfaz IRolRepository


Definición de claims y policies base


Autenticación JWT
Creación de endpoints de registro y login


Implementación de generación y validación de JWT


Configuración de middleware de autenticación y autorización


Gestión de Tenants
Creación de entidad Tenant


Creación de relación Usuario-Tenant


Creación de interfaz ITenantProvider


Implementación de TenantProvider


Email básico
Creación de interfaz IEmailService


Implementación de servicio de email fake/dev


Manejo de errores global
Implementación de middleware de manejo de errores


EF Core y PostgreSQL
Configuración de AppDbContext


Configuración de conexión a PostgreSQL


Creación de migraciones iniciales


Implementación de repositorios concretos y UnitOfWork


Configuración y secretos
Definición de settings para email, JWT y DB


Preparación de gestión de secretos en entorno local



Arquitectura principal de software

Layer 0 (Front): BFF + FRONT-API

Layer A: API Gateway + OAuth Check + Middleware

Layer B: Hexagonal Architecture (Adapters, domain, infra, ports, etc) + Outbox + DB

Layer C: Event Driven Application (KAFKA, NATS, RabbitMQ) - (Opcional)

Layer D: Third Party Application Manager.

Layer E: Telemetry + Auditory.

Autenticacion/Auth: 
	Registro, login, refresh tokens (JWT + bearer)
	Roles, permissions, claims
	Policies

Users/Perfiles
Creo que lo mas adecuado seria que esten separados del primer punto, asi se podrian definir segun cliente, necesidad, etc.

Tenancy/Ownership
Saber si hay recursos o modulos designados para ciertas areas, relacionados o para clientes/usuarios concretos.

Auditoria basica / BaseEntity

Notificaciones?

Resumen de organizacion por carpetas DDD, Hexagonal y Clean.
Api: Organiza por bounded context → modelo de dominio. El corazon: las reglas, entidades y VO.
Porque aquí vive el lenguaje del negocio. Debe estar aislado de detalles tecnicos
Ejemplo: Domain/Core --> Identity ---> Entities, VO, etc.

Application: organiza por feature → caso de uso. Facil acceso con pocos clicks. Es el Qué. 
Porque aquí vive la lógica del negocio. Orquestas flujos de negocio usando domain y puertos.
Ejemplo: Application --> Auth --> Login, Register, etc

Infra: organiza por bounded context → tipo técnico. Es el cómo.
Porque los repositorios y el DbContext no pertenecen a un caso de uso, sino a todo el bounded context.
Ejemplo: Infra --> Persistence, Security, Messaging, etc (Adaptadores tecnicos)

Api/Presentacion: Organiza por bounded context → feature (controller). Es la cara pública: HTTP, JSON, endpoints, controladores.
Porque expone los casos de uso al exterior. Es el traductor para fuera.
Ejemplo: Api --> Auth --> AuthController, Request, Responses....

Test: Organiza los tests “mirroring” Application/Domain
Porque quieres que sea muy fácil encontrar los tests de un caso de uso concreto
Ejemplo: Identity --> Auth --> Login, Register --> LoginHandlerTest, RegisterHandlerTest…


Quiero organizar esta semana. Trabajare los 7 días.
5 a jornada completa y sábado y domingo media jornada.(mañana)

Considero que mi proyecto tiene una base solida pero tengo varios posibles frentes ahora mismo. Te planteo las opciones y quiero que hagas un estudio de que consideras que debería abordar antes. 
Por un lado podria terminar el sistema de manejo de errores para hacerlo del todo robusto y asegurarme de que tengo total control interno de que pasa y donde falla. 
Es decir, debería implementar middleware global de expeciones + logs + enriquecer Error.Message internos para que sean mas útiles y descriptivos. (Esta ultima parte logs + errores seria fácil y rápida porque tengo pocos como tal ahora mismo)
Luego tengo varias features mas por implementar: MFA, Email Verification, Logging con Google y Bloqueo de seguridad tras varios intentos.
También creo que debería empezar a hacer testing (No estoy seguro de en que fase o en que momento empezar con el testing)


