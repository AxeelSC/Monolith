Gestión de Usuarios:
Core INICIAL
Usuarios
Creación de entidad Usuario


Creación de Value Object Email


Creación de interfaz IUsuarioRepository


Implementación de UserManagerService


Implementación de lógica de hasheo de contraseñas


Roles y Claims
Creación de entidad Rol


Creación de relación Usuario-Rol


Creación de interfaz IRolRepository


Definición de claims y policies base


Autenticación JWT
Creación de endpoints de registro y login


Implementación de generación y validación de JWT


Configuración de middleware de autenticación y autorización


Gestión de Tenants
Creación de entidad Tenant


Creación de relación Usuario-Tenant


Creación de interfaz ITenantProvider


Implementación de TenantProvider


Email básico
Creación de interfaz IEmailService


Implementación de servicio de email fake/dev


Manejo de errores global
Implementación de middleware de manejo de errores


EF Core y PostgreSQL
Configuración de AppDbContext


Configuración de conexión a PostgreSQL


Creación de migraciones iniciales


Implementación de repositorios concretos y UnitOfWork


Configuración y secretos
Definición de settings para email, JWT y DB


Preparación de gestión de secretos en entorno local



Arquitectura principal de software

Layer 0 (Front): BFF + FRONT-API

Layer A: API Gateway + OAuth Check + Middleware

Layer B: Hexagonal Architecture (Adapters, domain, infra, ports, etc) + Outbox + DB

Layer C: Event Driven Application (KAFKA, NATS, RabbitMQ) - (Opcional)

Layer D: Third Party Application Manager.

Layer E: Telemetry + Auditory.

Autenticacion/Auth: 
	Registro, login, refresh tokens (JWT + bearer)
	Roles, permissions, claims
	Policies

Users/Perfiles
Creo que lo mas adecuado seria que esten separados del primer punto, asi se podrian definir segun cliente, necesidad, etc.

Tenancy/Ownership
Saber si hay recursos o modulos designados para ciertas areas, relacionados o para clientes/usuarios concretos.

Auditoria basica / BaseEntity

Notificaciones?

Resumen de organizacion por carpetas DDD, Hexagonal y Clean.
Api: Organiza por bounded context → modelo de dominio. El corazon: las reglas, entidades y VO.
Porque aquí vive el lenguaje del negocio. Debe estar aislado de detalles tecnicos
Ejemplo: Domain/Core --> Identity ---> Entities, VO, etc.

Application: organiza por feature → caso de uso. Facil acceso con pocos clicks. Es el Qué. 
Porque aquí vive la lógica del negocio. Orquestas flujos de negocio usando domain y puertos.
Ejemplo: Application --> Auth --> Login, Register, etc

Infra: organiza por bounded context → tipo técnico. Es el cómo.
Porque los repositorios y el DbContext no pertenecen a un caso de uso, sino a todo el bounded context.
Ejemplo: Infra --> Persistence, Security, Messaging, etc (Adaptadores tecnicos)

Api/Presentacion: Organiza por bounded context → feature (controller). Es la cara pública: HTTP, JSON, endpoints, controladores.
Porque expone los casos de uso al exterior. Es el traductor para fuera.
Ejemplo: Api --> Auth --> AuthController, Request, Responses....

Test: Organiza los tests “mirroring” Application/Domain
Porque quieres que sea muy fácil encontrar los tests de un caso de uso concreto
Ejemplo: Identity --> Auth --> Login, Register --> LoginHandlerTest, RegisterHandlerTest…


Quiero organizar esta semana. Trabajare los 7 días.
5 a jornada completa y sábado y domingo media jornada.(mañana)

Considero que mi proyecto tiene una base solida pero tengo varios posibles frentes ahora mismo. Te planteo las opciones y quiero que hagas un estudio de que consideras que debería abordar antes. 
Por un lado podria terminar el sistema de manejo de errores para hacerlo del todo robusto y asegurarme de que tengo total control interno de que pasa y donde falla. 
Es decir, debería implementar middleware global de expeciones + logs + enriquecer Error.Message internos para que sean mas útiles y descriptivos. (Esta ultima parte logs + errores seria fácil y rápida porque tengo pocos como tal ahora mismo)
Luego tengo varias features mas por implementar: MFA, Email Verification, Logging con Google y Bloqueo de seguridad tras varios intentos.
También creo que debería empezar a hacer testing (No estoy seguro de en que fase o en que momento empezar con el testing)


Bow: Power, Punch, Homing ( i dont get what this does), Detonate, End Step, Hunter
xbow: Piercing, Quick Charge, Ceaseless (Infinite), Crescendo of bolts, Endless Quiver (All type of arrows infinite), Sharpshooter (Seems incompatible with piercing), Hunter

Venomous 8 (Works on bow and xbow), Chain Lighning 7 (I dont get how it works nor for melee or ranged), Critical Sunder 6 (I guess it also works), True Edge (I dont know), Misanthopy 10 (works on bow and xbow 100%), 

Slayer vs Sharpness, Scavenger, Capturing, Looting, mending, Sweeping Edge

Sharpness or Slayer, Critical Sunder, True Edge?, Misantropy?, Fire Aspect 5, 


Escribeme este resumen de la siguiente manera. EN lugar de poner en todo un apartado de WHY/DECISIONS, explicalo brevemente.
Ejemplo:
Titulo: Exposicion de informacion al cliente. Capas de seguridad y manejo de errores

Para el control de errores se han llevado a cabo diferentes decisiones. Primero se implementa el uso de result como medida de seguridad y de informacion adicional, etc...Segundo usamos una capa extra con api response de cara al cliente. Tercero usamos un middleware que gestione los errores, cuarto, definimos los errores en un archivo x de la siguiente manera (Explicar decisiones que se han llevado a cabo como el uso de constantes, factory method, conventions, etc) y en cada uno explicas brevemente porque se ha elegido y que aporta. SIn separar por why/decision y sin bloques de codigo de ejemplo.

A